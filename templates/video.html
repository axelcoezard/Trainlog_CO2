{% block content %}

<!-- Mapbox GL JS -->
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

<!-- Turf.js -->
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<!-- jQuery -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<!-- WebM duration/seek fix -->
<script src="https://unpkg.com/ts-ebml@3.0.3/dist/ebml.min.js"></script>

<!-- Icons -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet"/>

<style>
  :root{
    --bg:#0e0f13;
    --panel:#171a21;
    --panel:#171a21;
    --card:#1e222b;
    --muted:#aab2c0;
    --accent:#00e0ff;
    --accent-2:#7cf7c5;
    --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{background:radial-gradient(1200px 800px at 10% -10%, #1b2130 0%, rgba(27,33,48,0) 50%), var(--bg);}

  .page{
    max-width:1200px;margin:24px auto;padding:0 16px;
  }
  .header{
    display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;color:#fff;
  }
  .title{font-size:28px;font-weight:700;letter-spacing:.3px}
  .subtitle{color:var(--muted);font-size:14px}

  .layout{
    display:grid;grid-template-columns: 1fr 380px;gap:16px;
  }
  @media (max-width:1100px){
    .layout{grid-template-columns: 1fr}
  }

  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0) 30%), var(--panel);
    border:1px solid rgba(255,255,255,.08);
    border-radius:16px;padding:16px;color:#e7edf5;
    box-shadow:0 10px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
  }

  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-bottom:12px}
  .btn{
    display:inline-flex;align-items:center;gap:8px;
    background:#2b3342;color:#fff;border:1px solid rgba(255,255,255,.1);
    padding:10px 14px;border-radius:12px;cursor:pointer;
    transition:transform .15s ease, background .15s ease, border-color .15s ease;
    user-select:none;
  }
  .btn:hover{transform:translateY(-1px);background:#353f54;border-color:rgba(255,255,255,.18)}
  .btn:disabled{opacity:.55;cursor:not-allowed;transform:none}
  .btn.primary{background:linear-gradient(180deg, rgba(0,224,255,.25), rgba(0,224,255,.1));border-color:rgba(0,224,255,.55)}
  .btn.danger{background:linear-gradient(180deg, rgba(255,107,107,.25), rgba(255,107,107,.1));border-color:rgba(255,107,107,.6)}

  .progress{height:12px;background:#131620;border-radius:999px;border:1px solid rgba(255,255,255,.08);overflow:hidden;margin:10px 0}
  .progress-bar{height:100%;width:0%;
    background:linear-gradient(90deg, var(--accent), var(--accent-2));transition:width .2s ease}

  .status{color:var(--muted);font-size:13px;margin-top:4px;min-height:18px}

  .map-wrap{
    position:relative;background:var(--card);
    border:1px solid rgba(255,255,255,.08);
    border-radius:16px;overflow:hidden;
  }
  #map{width:100%;height:100%}

  /* Default export is square 1080 × 1080; scale down if you prefer */
  .map-wrap{width:1080px;max-width:100%;aspect-ratio:1/1;margin:auto}
  .map-inner{position:relative;width:100%;height:100%}
  .logo-preview{
    position:absolute;left:16px;bottom:16px;width:min(18%,160px);opacity:.9;z-index:10;pointer-events:none
  }

  /* Spinner */
  .spinner{position:absolute;inset:0;display:grid;place-items:center;z-index:30;backdrop-filter:blur(1px)}
  .spinner.hidden{display:none}
  .lds{color:#fff;width:64px;height:64px;position:relative}
  .lds:before, .lds:after{content:"";position:absolute;border:6px solid transparent;border-top-color:#fff;border-radius:50%;inset:0;animation:spin 1s linear infinite}
  .lds:after{inset:8px;border-top-color:var(--accent);animation-duration:1.5s}
  @keyframes spin{to{transform:rotate(360deg)}}

  /* Right panel lists */
  .trip-info h3{margin:0 0 12px 0;font-size:16px;color:#d9e3f0}
  .trip-list{display:flex;flex-direction:column;gap:10px;max-height:50vh;overflow:auto}
  .trip-item{background:#1a1f29;border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:10px}
  .trip-item strong{color:#fff}
  .trip-item small{color:#9aa6b2}

  .settings{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .field{display:flex;flex-direction:column;gap:6px}
  .field label{font-size:12px;color:#c8d2df}
  .field input,.field select{
    background:#12161f;border:1px solid rgba(255,255,255,.1);color:#e7edf5;
    padding:8px 10px;border-radius:10px
  }

  .footer-note{color:#7b8794;font-size:12px;margin-top:8px}
</style>

<div class="page">
  <div class="header">
    <div>
      <div class="title">{{videoTitle|default('Cinematic Trip Video Generator')}}</div>
      <div class="subtitle">Ultra-smooth, tile-warmed, seekable export with baked logo</div>
    </div>
    <div class="subtitle">v2 — smooth fill · warm-up pass · 1080p ready</div>
  </div>

  <div class="layout">
    <!-- Left: Map & transport -->
    <div class="panel">
      <div class="controls">
        <button class="btn" id="loadBtn"><i class="fa-solid fa-download"></i>{{loadTrips|default('Load Trips')}}</button>
        <button class="btn" id="previewBtn" disabled><i class="fa-solid fa-play"></i>{{preview|default('Preview')}}</button>
        <button class="btn primary" id="recordBtn" disabled><i class="fa-solid fa-video"></i>{{generateVideo|default('Record 1080p')}}</button>
        <button class="btn danger" id="stopBtn" style="display:none"><i class="fa-solid fa-stop"></i>{{stop|default('Stop')}}</button>
        <button class="btn" id="backBtn"><i class="fa-solid fa-arrow-left"></i>{{back|default('Back')}}</button>
      </div>

      <div class="progress"><div class="progress-bar" id="progressBar"></div></div>
      <div class="status" id="status">{{ready|default('Ready')}}</div>

      <div class="map-wrap" id="mapWrap">
        <div class="spinner hidden" id="spinner"><div class="lds"></div></div>
        <div class="map-inner">
          <div id="map"></div>
          <!-- Preview-only overlay; the composite canvas bakes the logo into the recording -->
          <img class="logo-preview" id="logoPreview" src="{{ url_for('static', filename='images/logo.png') }}" alt="Logo">
        </div>
      </div>

      <!-- Off-DOM composite canvas for recording (bakes map + logo) -->
      <canvas id="compositeCanvas" width="1080" height="1080" style="display:none"></canvas>

      <div class="footer-note">
        Tip: For 4K, set "Resolution" to 2160 and increase bitrate.
      </div>
    </div>

    <!-- Right: Details & settings -->
    <div class="panel">
      <div class="trip-info">
        <h3>{{tripDetails|default('Trip Details')}}</h3>
        <div class="trip-list" id="tripList"></div>
      </div>

      <hr style="border-color:rgba(255,255,255,.08);margin:14px 0">

      <div class="trip-info">
        <h3>Export Settings</h3>
        <div class="settings">
          <div class="field">
            <label>Duration (seconds)</label>
            <input type="number" id="durInput" min="5" max="120" value="30">
          </div>
          <div class="field">
            <label>FPS</label>
            <select id="fpsInput">
              <option>24</option>
              <option selected>30</option>
              <option>60</option>
            </select>
          </div>
          <div class="field">
            <label>Resolution (height px)</label>
            <select id="resInput">
              <option value="720">720</option>
              <option value="1080" selected>1080</option>
              <option value="1440">1440</option>
              <option value="2160">2160</option>
            </select>
          </div>
          <div class="field">
            <label>Bitrate (Mbps)</label>
            <select id="bitrateInput">
              <option value="5">5</option>
              <option value="8" selected>8</option>
              <option value="10">10</option>
              <option value="15">15</option>
            </select>
          </div>
        </div>
        <div class="footer-note">Logo is baked into the export.</div>
      </div>
    </div>
  </div>
</div>

<script>
  // ------ Mapbox token ------
  mapboxgl.accessToken = 'pk.eyJ1Ijoic2ltZnIyNCIsImEiOiJjamcza2xyNHMwaWk0MnFwcXdjM3g3bjdoIn0.PEjPB2weo9QKQG2EaYOt4A';

  // ------ UI elements ------
  const $status = document.getElementById('status');
  const $progressBar = document.getElementById('progressBar');
  const $spinner = document.getElementById('spinner');
  const $logoPreview = document.getElementById('logoPreview');

  function setStatus(msg){ $status.textContent = msg; }
  function setProgress(pct){ $progressBar.style.width = `${Math.max(0, Math.min(100, pct))}%`; }
  function setSpinner(show){ $spinner.classList.toggle('hidden', !show); }

let camSmoothCenter = null;   // [lng, lat] in mercator meters internally
let camSmoothBearing = null;

// simple web mercator conversions (meters), independent of map state
const R = 6378137; const PI = Math.PI;
function toMerc([lng, lat]){
  const x = R * (lng * PI/180);
  const y = R * Math.log(Math.tan(PI/4 + (lat * PI/180)/2));
  return [x, y];
}
function fromMerc([x, y]){
  const lng = (x / R) * 180/PI;
  const lat = (2 * Math.atan(Math.exp(y / R)) - PI/2) * 180/PI;
  return [lng, lat];
}
function lerp(a, b, t){ return a + (b - a) * t; }
function lerp2(a, b, t){ return [ lerp(a[0], b[0], t), lerp(a[1], b[1], t) ]; }

// shortest-angle lerp (degrees, wrap-aware)
function lerpAngle(a, b, t){
  let d = ((b - a + 540) % 360) - 180; // -180..180
  return a + d * t;
}

// reset smoothing when a new route loads or when we restart
function resetCameraSmoothing(desiredCenter, desiredBearing){
  camSmoothCenter  = toMerc(desiredCenter);
  camSmoothBearing = desiredBearing;
}


  // ------ Config / state ------
  let map;
  let tripIds = "{{tripIds}}";
  let trips = [];

  // animation parameters (dynamic from settings)
  let FPS = 30, DURATION = 30, TOTAL_FRAMES = 900, HEIGHT = 1080, BITRATE = 8_000_000;

  // route segments - now separate per trip
  let routeSegments = [];     // Array of {tripIndex, coords, type, feature, distance}
  let allRouteCoords = [];    // Combined coords for camera movement
  let totalRouteDistance = 0; // Total distance for proportional timing

  // composite recording
  let compositeCanvas, compositeCtx, compositeLogoImg, compositeLogoReady = false;
  let mediaRecorder, recordedChunks = [], recording = false;

  // ------ Helpers ------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  

  function waitForIdle(){
    return new Promise(resolve=>{
      if (map.areTilesLoaded && map.areTilesLoaded()) return resolve();
      const onIdle=()=>{ map.off('idle', onIdle); resolve(); };
      map.on('idle', onIdle);
    });
  }

  function lngLatBoundsOf(coords){
    return coords.reduce((b,c)=>b.extend(c), new mapboxgl.LngLatBounds(coords[0], coords[0]));
  }

  // ------ Build route segments (separate per trip) ------
function buildRouteSegments(trips){
  routeSegments = [];
  allRouteCoords = [];
  totalRouteDistance = 0;
  
  for (let i = 0; i < trips.length; i++) {
    const trip = trips[i];
    const tripType = trip.trip?.type || "train";
    
    // Convert [lat,lng] -> [lng,lat]
    const coords = (trip.path || [])
      .map(p => Array.isArray(p) && p.length >= 2 ? [parseFloat(p[1]), parseFloat(p[0])] : null)
      .filter(p => p && !Number.isNaN(p[0]) && !Number.isNaN(p[1]));
    
    if (coords.length < 2) continue;
    
    let processedCoords;
    let segmentDistance;
    
    // Special handling for air/helicopter - straight line, no terrain following
    if (tripType === 'air' || tripType === 'helicopter') {
      // Just use start and end points, densify as straight line
      const start = coords[0];
      const end = coords[coords.length - 1];
      processedCoords = densifyStraightLine(start, end);
      // Calculate straight-line distance
      segmentDistance = turf.distance(start, end, {units: 'kilometers'});
    } else {
      // Use original coordinates with minimal processing - preserve detail
      const line = turf.lineString(coords);
      segmentDistance = turf.length(line, {units: 'kilometers'});
      
      // Keep original coordinates but add some intermediate points for very sparse routes
      if (coords.length < 50) {
        // Only densify if route is very sparse
        const stepMeters = Math.min(1000, (segmentDistance * 1000) / 100); // Max 1km steps
        processedCoords = densifyByStep(coords, stepMeters);
      } else {
        // Use original coordinates to preserve detail
        processedCoords = coords;
      }
    }
    
    // Create feature for this segment
    const feature = {
      type: 'Feature',
      geometry: { type: 'LineString', coordinates: processedCoords }
    };
    
    routeSegments.push({
      tripIndex: i,
      coords: processedCoords,
      type: tripType,
      feature: feature,
      distance: segmentDistance
    });
    
    totalRouteDistance += segmentDistance;
    
    // Add to combined coords for camera movement
    allRouteCoords = allRouteCoords.concat(processedCoords);
    // Build a single line for along-route sampling (for helicopter follow)
    combinedLine = allRouteCoords.length >= 2 ? turf.lineString(allRouteCoords) : null;
    combinedLenKm = combinedLine ? turf.length(combinedLine, { units: 'kilometers' }) : 0;
  }
}

// Densify straight line (for air routes)
function densifyStraightLine(start, end, points = 50) {
  const result = [];
  for (let i = 0; i <= points; i++) {
    const t = i / points;
    const lng = start[0] + (end[0] - start[0]) * t;
    const lat = start[1] + (end[1] - start[1]) * t;
    result.push([lng, lat]);
  }
  return result;
}

  function densifyByStep(coords, stepMeters){
    const line = turf.lineString(coords);
    const lenKm = turf.length(line, {units:'kilometers'});
    const steps = Math.max(2, Math.ceil((lenKm*1000)/stepMeters));
    const out = [];
    for (let i=0;i<=steps;i++){
      const p = turf.along(line, (lenKm * i)/steps, {units:'kilometers'});
      out.push(p.geometry.coordinates);
    }
    return out;
  }

  // ------ Map init & layers ------
  function initMap(){
    map = new mapboxgl.Map({
      container:'map',
      style:'mapbox://styles/mapbox/satellite-streets-v12',
      center:[0,0], zoom:2, pitch:45, bearing:0,
      antialias:true, preserveDrawingBuffer:true
    });

    map.on('load', ()=>{
      map.addSource('mapbox-dem', {
        type:'raster-dem', url:'mapbox://mapbox.mapbox-terrain-dem-v1',
        tileSize:512, maxzoom:14
      });
      map.setTerrain({source:'mapbox-dem', exaggeration:1.5});
      map.addLayer({ id:'sky', type:'sky', paint:{
        'sky-type':'atmosphere',
        'sky-atmosphere-sun':[0.0,90.0],
        'sky-atmosphere-sun-intensity':14
      }});
      if (map.setPrefetchTiles) map.setPrefetchTiles(true);
      setStatus("{{mapReady|default('Map ready')}}");
    });

    // composite canvas & logo
    compositeCanvas = document.getElementById('compositeCanvas');
    compositeCtx = compositeCanvas.getContext('2d');

    compositeLogoImg = new Image();
    compositeLogoImg.onload = ()=>{ compositeLogoReady = true; };
    compositeLogoImg.src = "{{ url_for('static', filename='images/logo.png') }}";
  }

function addRouteLayers(){
  // Remove existing route layers
  routeSegments.forEach((segment, index) => {
    const layerId = `route-segment-${index}`;
    const sourceId = `route-source-${index}`;
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
  });

  // Add separate layer for each trip segment
  routeSegments.forEach((segment, index) => {
    const color = TYPE_COLORS[segment.type] || "#7cf7c5";
    const sourceId = `route-source-${index}`;
    const layerId = `route-segment-${index}`;
    
    map.addSource(sourceId, { 
      type: 'geojson', 
      lineMetrics: true, 
      data: segment.feature, 
      tolerance: 0 
    });

    map.addLayer({
      id: layerId,
      type: 'line',
      source: sourceId,
      layout: { 'line-cap': 'round', 'line-join': 'round' },
      paint: {
        'line-width': segment.type === 'air' || segment.type === 'helicopter' ? 6 : 8, // Slightly thinner for air routes
        'line-opacity': segment.type === 'air' || segment.type === 'helicopter' ? 0.8 : 1, // Slightly more transparent for air routes
        'line-color': color,
        'line-trim-offset': [0, 0]
      }
    });
  });
}



  function fitToRoute(){
    if (allRouteCoords.length === 0) return;
    const b = lngLatBoundsOf(allRouteCoords);
    map.fitBounds(b, {padding:120, duration:0});
  }

  // ------ Progress & camera ------
function setRouteProgress(p){
  p = clamp01(p);
  
  if (totalRouteDistance === 0) return;
  
  // Calculate progress based on actual distance, not coordinate count
  const targetDistance = p * totalRouteDistance;
  let currentDistance = 0;
  
  routeSegments.forEach((segment, index) => {
    const segmentStartDistance = currentDistance;
    const segmentEndDistance = currentDistance + segment.distance;
    
    let segmentProgress;
    if (targetDistance <= segmentStartDistance) {
      segmentProgress = 0; // Not started yet
    } else if (targetDistance >= segmentEndDistance) {
      segmentProgress = 1; // Fully revealed
    } else {
      // Partially revealed - calculate progress within this segment
      segmentProgress = (targetDistance - segmentStartDistance) / segment.distance;
    }
    
    // Set trim offset for this segment
    const layerId = `route-segment-${index}`;
    const startTrim = segmentProgress;
    const endTrim = 1;
    
    if (map.getLayer(layerId)) {
      map.setPaintProperty(layerId, 'line-trim-offset', [startTrim, endTrim]);
    }
    
    currentDistance += segment.distance;
  });
}


// Follow-cam tuning
const CAM_ALPHA_POS   = 0.03;   // stronger smoothing for buttery motion
const CAM_ALPHA_BEAR  = 0.015;
const CAMERA_ZOOM     = 10;     // "about 10"
const CAMERA_PITCH    = 45;
const CAMERA_LEAD_M   = 1200;   // meters to look ahead along the path
const SUBJECT_OFFSET_Y_FRAC = 0.12; // keep subject slightly below center (12% of viewport)

let combinedLine = null;   // turf line of the entire route
let combinedLenKm = 0;     // total length in km


const TYPE_COLORS = {
  air: "rgb(64,185,31)",
  helicopter: "rgb(64,185,31)",
  train: "rgb(82,176,254)",
  tram: "rgb(162,215,255)",
  metro: "rgb(0,69,149)",
  bus: "rgb(159,75,187)",
  ferry: "rgb(30,30,124)",
  car: "rgb(166,143,205)",
  cycle: "rgb(110,33,26)",
  walk: "rgb(232,140,0)",
  aerialway: "rgb(175,207,59)"
};


// ---- Bearing smoothing helpers ----
function angleDiffDeg(a, b){
  // shortest signed diff b-a in [-180,180)
  return ((b - a + 540) % 360) - 180;
}

function clamp(val, lo, hi){ return Math.max(lo, Math.min(hi, val)); }

function avgBearingDeg(bearingsDeg, weights){
  // Vector (cos/sin) average to avoid wrap issues, weights sum arbitrary
  let x = 0, y = 0;
  for (let i = 0; i < bearingsDeg.length; i++){
    const rad = bearingsDeg[i] * Math.PI/180;
    const w   = weights ? (weights[i] || 0) : 1;
    x += Math.cos(rad) * w;
    y += Math.sin(rad) * w;
  }
  if (x === 0 && y === 0) return bearingsDeg[0] || 0;
  let deg = Math.atan2(y, x) * 180/Math.PI;
  if (deg < 0) deg += 360;
  return deg;
}


function setCamera(p){
  p = clamp01(p);
  if (!combinedLine || combinedLenKm <= 0) return;

  // Where are we along the route?
  const distKm        = p * combinedLenKm;
  const leadKm        = Math.max(0, Math.min(combinedLenKm, distKm + (CAMERA_LEAD_M / 1000)));
  const hereFeature   = turf.along(combinedLine, distKm, { units: 'kilometers' });
  const aheadFeature  = turf.along(combinedLine, leadKm, { units: 'kilometers' });

  const here  = hereFeature.geometry.coordinates;   // [lng, lat]
  const ahead = aheadFeature.geometry.coordinates;  // [lng, lat]

  // Bearing from tangent (helicopter "pointing where we go")
  // Small helper: turf.bearing returns -180..180
  let desiredBearing = turf.bearing(here, ahead);
  desiredBearing = (desiredBearing + 360) % 360;

  // First frame seed for smoothing
  if (!camSmoothCenter || camSmoothBearing == null){
    resetCameraSmoothing(here, desiredBearing);
  }

  // Smooth center & bearing
  const mercDesired = toMerc(here);
  camSmoothCenter   = lerp2(camSmoothCenter, mercDesired, CAM_ALPHA_POS);
  camSmoothBearing  = lerpAngle(camSmoothBearing, desiredBearing, CAM_ALPHA_BEAR);
  const smoothedCenter = fromMerc(camSmoothCenter);

  // Keep subject a touch low in the frame (cinematic). Offset is in **pixels**.
  const canvas = map.getCanvas();
  const offsetPx = [0, SUBJECT_OFFSET_Y_FRAC * canvas.height];

  // Regular jumpTo = unaffected by terrain elevation
  map.jumpTo({
    center:  smoothedCenter,
    bearing: camSmoothBearing,
    pitch:   CAMERA_PITCH,
    zoom:    CAMERA_ZOOM,
    offset:  offsetPx
  });
}



  // ------ Enhanced tile preloading with buffer zones ------
  // meters-to-degrees helper (good enough for small offsets)
function offsetLngLatMeters([lng, lat], dxMeters, dyMeters){
  const rad = Math.PI/180;
  const dLat = (dyMeters / 111320); // ~ meters per deg latitude
  const dLng = (dxMeters / (111320 * Math.cos(lat * rad)));
  return [lng + dLng, lat + dLat];
}

// aggressive preloader: samples along route × bearings × zooms × padded grid
async function preloadTilesWithPadding({
  samples = 40,           // more samples -> more thorough warm-up
  padMeters = 4000,       // how far around each point to load tiles
  zooms = [14.0, 14.8, 15.5],
  bearings = [0, 45, 90, 135, 180, 225, 270, 315],
  grid = [[0,0], [1,0], [-1,0], [0,1], [0,-1], [1,1], [-1,1], [1,-1], [-1,-1]]
} = {}){
  setSpinner(true);
  setStatus("Warming tiles (wide padding)...");
  setProgress(0);

  if (allRouteCoords.length === 0) return;

  // sample indices along the combined route
  const N = allRouteCoords.length;
  const idxs = [];
  for (let i=0; i<samples; i++){
    idxs.push(Math.round((i/(samples-1)) * (N-1)));
  }

  // remember current camera to restore later
  const cam = map.getFreeCameraOptions
    ? map.getFreeCameraOptions()
    : { center: map.getCenter(), zoom: map.getZoom(), bearing: map.getBearing(), pitch: map.getPitch() };

  let stepsDone = 0;
  const stepsTotal = idxs.length * bearings.length * zooms.length * grid.length;

  // tighten the idle wait a bit but still ensure coverage
  const waitIdle = (timeout=900) => new Promise(resolve=>{
    const start = performance.now();
    const check = ()=>{
      if (map.areTilesLoaded && map.areTilesLoaded()) return resolve();
      if (performance.now() - start > timeout) return resolve();
      setTimeout(check, 40);
    };
    check();
  });

  for (const i of idxs){
    const base = allRouteCoords[i];

    // compute grid centers around the base point
    const centers = grid.map(([gx, gy]) => offsetLngLatMeters(base, gx * padMeters, gy * padMeters));

    for (const bearing of bearings){
      for (const zoom of zooms){
        for (const c of centers){
          map.jumpTo({ center: c, zoom, bearing, pitch: CAMERA_PITCH });
          // brief settle, then wait for tiles (or timeout)
          await waitIdle();
          stepsDone++;
          if ((stepsDone & 3) === 0){ // update UI every few steps
            setProgress((stepsDone/stepsTotal)*100);
            setStatus(`Warming tiles… ${Math.round((stepsDone/stepsTotal)*100)}%`);
          }
        }
      }
    }
  }

  // restore camera (to start)
  setCamera(0);

  setSpinner(false);
  setProgress(0);
  setStatus("Tiles warmed with wide padding");
}
  // ------ Composite (map + logo) ------
  function drawComposite(){
    const mc = map.getCanvas();

    // Match map canvas size
    if (compositeCanvas.width !== mc.width || compositeCanvas.height !== mc.height){
      compositeCanvas.width = mc.width;
      compositeCanvas.height = mc.height;
    }

    compositeCtx.clearRect(0,0,compositeCanvas.width, compositeCanvas.height);
    compositeCtx.drawImage(mc, 0, 0);

    // Logo
    if (compositeLogoReady){
      const w = Math.floor(0.18 * compositeCanvas.width);
      const ar = (compositeLogoImg.naturalHeight||320)/(compositeLogoImg.naturalWidth||1000);
      const h = Math.floor(w*ar);
      const pad = Math.floor(0.03 * compositeCanvas.width);
      compositeCtx.globalAlpha = 0.9;
      compositeCtx.drawImage(compositeLogoImg, pad, compositeCanvas.height - h - pad, w, h);
      compositeCtx.globalAlpha = 1;
    }
  }

  // ------ Loops ------
  function previewLoop(done){
    let f = 0;
    function step(){
      const p = f/(TOTAL_FRAMES-1);
      setRouteProgress(p);
      setCamera(p);
      drawComposite();
      setProgressUI(p);
      f++;
      if (f < TOTAL_FRAMES) requestAnimationFrame(step);
      else done && done();
    }
    requestAnimationFrame(step);
  }

  function recordLoop(done){
    const frameMs = 1000/FPS;
    let f = 0, next = performance.now();
    function tick(){
      const now = performance.now();
      if (now >= next - 1){
        const p = f/(TOTAL_FRAMES-1);
        setRouteProgress(p);
        setCamera(p);
        drawComposite();
        setProgressUI(p);
        f++; next += frameMs;
      }
      if (f < TOTAL_FRAMES && recording) {
        setTimeout(tick, Math.max(0, next - performance.now()));
      } else {
        done && done();
      }
    }
    setTimeout(tick, 0);
  }

  function setProgressUI(p){ setProgress(p*100); }

  // ------ Trips & UI ------
  function renderTripList(list){
    const $list = document.getElementById('tripList');
    $list.innerHTML = '';
    list.forEach((t,i)=>{
      const div = document.createElement('div');
      div.className = 'trip-item';
      const tripType = (t.trip.type==='helicopter'?'air':t.trip.type) || '—';
      const color = TYPE_COLORS[t.trip.type] || '#7cf7c5';
      div.innerHTML = `
        <strong style="color: ${color}">${i+1}. ${tripType}</strong><br>
        ${t.trip.origin_station} → ${t.trip.destination_station}<br>
        <small>${t.trip.start_time} – ${t.trip.end_time}</small>
      `;
      $list.appendChild(div);
    });
  }

  async function loadTrips(){
    setSpinner(true);
    setStatus("{{loadingTrips|default('Loading trips...')}}");
    return new Promise((resolve, reject)=>{
      $.post({
        url: '{{url_for("getPublicTrips")}}',
        contentType:'application/json',
        data: JSON.stringify({ tripIds }),
        success: async data=>{
          trips = data[0] || [];
          trips.reverse();
          renderTripList(trips);

          // Build route segments (separate per trip)
          buildRouteSegments(trips);
          if (routeSegments.length === 0 || allRouteCoords.length < 2){
            setSpinner(false); setStatus("{{noValidCoordinates|default('No valid coordinates found')}}"); return;
          }

          // Add layers for each segment
          addRouteLayers();
          fitToRoute();
          resetCameraSmoothing(allRouteCoords[0], (()=>{
            // initial tangent bearing
            const a = allRouteCoords[0], b = allRouteCoords[Math.min(5, allRouteCoords.length-1)];
            const toRad = Math.PI/180, toDeg = 180/Math.PI;
            const [lon1, lat1] = [a[0]*toRad, a[1]*toRad];
            const [lon2, lat2] = [b[0]*toRad, b[1]*toRad];
            const y = Math.sin(lon2-lon1) * Math.cos(lat2);
            const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(lon2-lon1);
            return (Math.atan2(y, x) * toDeg + 360) % 360;
          })());
          await waitForIdle();

          // Warm up the exact animation path
          // (prevents mid-record tile loading)
          await preloadTilesWithPadding({
            samples: 48,          // feel free to tweak
            padMeters: 5000,      // "a lot of padding"
            zooms: [13.8, 14.8, 15.8],
            bearings: [0, 60, 120, 180, 240, 300]
          });

          setSpinner(false);
          setStatus("{{tripsLoaded|default('Trips loaded & warmed')}}");
          resolve();
        },
        error: err=>{
          setSpinner(false);
          setStatus("{{errorLoading|default('Error loading trips')}}");
          reject(err);
        }
      });
    });
  }

  function applySettings(){
    const fps = parseInt(document.getElementById('fpsInput').value, 10);
    const dur = parseInt(document.getElementById('durInput').value, 10);
    const res = parseInt(document.getElementById('resInput').value, 10);
    const mbps = parseInt(document.getElementById('bitrateInput').value, 10);

    FPS = Math.max(1, fps);
    DURATION = Math.max(5, dur);
    TOTAL_FRAMES = FPS * DURATION;
    HEIGHT = res;
    BITRATE = (mbps * 1_000_000) | 0;

    // Resize export canvas + preview container to target res (square)
    const mapWrap = document.getElementById('mapWrap');
    mapWrap.style.aspectRatio = '1 / 1';
    // (DOM size adapts; Mapbox renders at devicePixelRatio * CSS pixels automatically)
    compositeCanvas.width = HEIGHT;
    compositeCanvas.height = HEIGHT;

    // Rebuild route segments to match new frame count for extra smoothness
    if (trips.length){
      buildRouteSegments(trips);
      if (routeSegments.length > 0) {
        addRouteLayers();
        fitToRoute();
      }
    }
  }

  // ------ Recording ------
  async function startRecording(){
    if (routeSegments.length === 0){ setStatus("{{noTripsToRecord|default('No trips')}}"); return; }

    // No additional tile loading before recording - should already be loaded
    
    // Just verify start position
    setCamera(0);
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Quick final verification at start position
    setRouteProgress(0); 
    setCamera(0); 
    await waitForIdle();
    
    setSpinner(false);

    // Prepare stream from composite (baked logo)
    const stream = compositeCanvas.captureStream(FPS);
    recordedChunks = [];
    const options = { mimeType:'video/webm;codecs=vp9', videoBitsPerSecond: BITRATE };
    if (!MediaRecorder.isTypeSupported(options.mimeType)) options.mimeType = 'video/webm';

    mediaRecorder = new MediaRecorder(stream, options);
    mediaRecorder.ondataavailable = e=>{ if (e.data && e.data.size>0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = async ()=>{
      const raw = new Blob(recordedChunks, {type: options.mimeType});
      let finalBlob = raw;
      try{
        if (window.EBML){ finalBlob = await makeWebMSeekable(raw, DURATION) || raw; }
      }catch(e){ console.warn('Seekable fix failed', e); }
      downloadVideo(finalBlob);
      recording = false;
    };

    // UI
    document.getElementById('recordBtn').style.display='none';
    document.getElementById('stopBtn').style.display='inline-flex';
    document.getElementById('previewBtn').disabled = true;

    recording = true;
    mediaRecorder.start();
    setStatus("{{recordingStarted|default('Recording...')}}");

    recordLoop(()=>{
      if (recording && mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop();
    });
  }

  function stopRecording(){
    recording = false;
    if (mediaRecorder && mediaRecorder.state!=='inactive') mediaRecorder.stop();
    document.getElementById('recordBtn').style.display='inline-flex';
    document.getElementById('stopBtn').style.display='none';
    document.getElementById('previewBtn').disabled = false;
    setStatus("{{processingVideo|default('Finalizing video...')}}");
  }

  function downloadVideo(blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.style.display='none';
    const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
    a.download = `trip_video_${HEIGHT}p_${FPS}fps_${DURATION}s_${ts}.webm`;
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setStatus("{{videoDownloaded|default('Video downloaded')}}");
    setProgress(0);
  }

  async function makeWebMSeekable(blob, durationSec){
    const ab = await blob.arrayBuffer();
    const reader = new EBML.Reader();
    const decoder = new EBML.Decoder();
    const elms = decoder.decode(new Uint8Array(ab));
    elms.forEach(el=>reader.read(el));
    reader.stop();
    const refined = EBML.tools.makeMetadataSeekable(reader.metadatas, durationSec*1000, reader.cues);
    const body = ab.slice(reader.metadataSize);
    return new Blob([refined, body], {type: blob.type});
  }

  // ------ Event wiring ------
  document.getElementById('loadBtn').addEventListener('click', async ()=>{
    // Apply settings first (affects densification target)
    applySettings();
    await loadTrips();
    document.getElementById('previewBtn').disabled = false;
    document.getElementById('recordBtn').disabled = false;
  });

  document.getElementById('previewBtn').addEventListener('click', ()=>{
    if (routeSegments.length === 0){ setStatus("{{noTripsToAnimate|default('No trips')}}"); return; }
    setStatus("{{animationRunning|default('Preview...')}}");
    previewLoop(()=> setStatus("{{animationComplete|default('Preview complete')}}"));
  });

  document.getElementById('recordBtn').addEventListener('click', startRecording);
  document.getElementById('stopBtn').addEventListener('click', stopRecording);
  document.getElementById('backBtn').addEventListener('click', ()=>history.back());

  document.getElementById('fpsInput').addEventListener('change', applySettings);
  document.getElementById('durInput').addEventListener('change', applySettings);
  document.getElementById('resInput').addEventListener('change', applySettings);
  document.getElementById('bitrateInput').addEventListener('change', applySettings);

  // ------ Boot ------
  window.addEventListener('load', ()=>{
    if (typeof mapboxgl === 'undefined'){
      setStatus("{{errorMapbox|default('Mapbox failed to load')}}");
      return;
    }
    initMap();
    applySettings();
  });
</script>

{% endblock %}